% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scfunction.R
\name{smoothchol}
\alias{smoothchol}
\title{Computes smoothed estimate for a fixed tuning parameter with different penalty options.}
\usage{
smoothchol(S, lambda1 = 0, lambda2, max_iter = 70, init.x = NULL,
  type = c("fused", "l1trend", "HP"), band = NULL, ABSTOL = 0.001)
}
\arguments{
\item{S}{Sample Covariance Matrix}

\item{lambda1}{lambda value to control the sparsity}

\item{lambda2}{lambda value to control smoothness}

\item{max_iter}{Number of maximum iteration}

\item{init.x}{initial value for vectorized Cholesky factor L.}

\item{band}{Positive number to select the band. If specified, algorithm forces the entries outside of band equal to zero and iterates only over specifed subdiagonals inside the band.}

\item{ABSTOL}{Tolerance for algorithm convergence.}
}
\value{
Returns the estimated smoothed Cholesky factor \code{L}
}
\description{
Solves the optimization problem in Dallakyan and Pourahmadi (2019) using
block-coordinate algorithm.
}
\examples{
set.seed(12)
p <- 50
band <- 5
L_true <- generateL(p = p, band = band)$L
library(varband)
X <- sample_gen(L = L_true, n = n)
sample covariance matrix
S <- crossprod(scale(X, center = TRUE, scale = FALSE)) / n
L_fused = smoothchol(S, lambda1 = 0, lambda2 = 0.2, type = "fused")$L
L_trend = smoothchol(S, lambda1 = 0, lambda2 = 0.2, type = "l1trend")$L
L_HP = smoothchol(S, lambda1 = 0, lambda2 = 0.2, type = "HP")$L

#' @seealso \\code{\\link{smoothcholCV}}

}
